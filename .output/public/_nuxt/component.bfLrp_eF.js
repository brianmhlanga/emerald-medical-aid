import{u as b}from"./vue.f36acd1f.sEZeFHUb.js";import{ad as O,r as m,ae as j,af as k,ag as B,ah as _,aa as R,m as h,ai as x,G as A,aj as C,R as H,ak as M,al as E}from"./entry.iBGuQRa0.js";const K=r=>r==="defer"||r===!1;function N(...r){var D;const f=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(f);let[e,c,a={}]=r;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=h(),p=()=>null,y=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??p,a.getCachedData=a.getCachedData??y,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??O.deep,a.dedupe=a.dedupe??"cancel";const i=()=>![null,void 0].includes(a.getCachedData(e));if(!t._asyncData[e]||!a.immediate){(D=t.payload._errors)[e]??(D[e]=null);const o=a.deep?m:j;t._asyncData[e]={data:o(a.getCachedData(e)??a.default()),pending:m(!i()),error:k(t.payload._errors,e),status:m("idle")}}const n={...t._asyncData[e]};n.refresh=n.execute=(o={})=>{if(t._asyncDataPromises[e]){if(K(o.dedupe??a.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((o._initial||t.isHydrating&&o._initial!==!1)&&i())return Promise.resolve(a.getCachedData(e));n.pending.value=!0,n.status.value="pending";const d=new Promise((s,u)=>{try{s(c(t))}catch(w){u(w)}}).then(s=>{if(d.cancelled)return t._asyncDataPromises[e];let u=s;a.transform&&(u=a.transform(s)),a.pick&&(u=z(u,a.pick)),t.payload.data[e]=u,n.data.value=u,n.error.value=null,n.status.value="success"}).catch(s=>{if(d.cancelled)return t._asyncDataPromises[e];n.error.value=x(s),n.data.value=A(a.default()),n.status.value="error"}).finally(()=>{d.cancelled||(n.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=d,t._asyncDataPromises[e]};const l=()=>n.refresh({_initial:!0}),P=a.server!==!1&&t.payload.serverRendered;{const o=C();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const s=o._nuxtOnBeforeMountCbs;o&&(B(()=>{s.forEach(u=>{u()}),s.splice(0,s.length)}),_(()=>s.splice(0,s.length)))}P&&t.isHydrating&&(n.error.value||i())?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):o&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?o._nuxtOnBeforeMountCbs.push(l):a.immediate&&l(),a.watch&&R(a.watch,()=>n.refresh());const d=t.hook("app:data:refresh",async s=>{(!s||s.includes(e))&&await n.refresh()});o&&_(d)}const v=Promise.resolve(t._asyncDataPromises[e]).then(()=>n);return Object.assign(v,n),v}function z(r,f){const e={};for(const c of f)e[c]=r[c];return e}const g="__nuxt_component";async function I(r,f){const e=h(),c=H(),a=C(),{fetchKey:t,_fetchKeyBase:p}=a.proxy.$options,y=(typeof t=="function"?t(()=>""):t)||[p,c.fullPath,c.matched.findIndex(l=>Object.values(l.components||{}).includes(a.type))].join(":"),{data:i,error:n}=await N(`options:asyncdata:${y}`,()=>e.runWithContext(()=>f(e)));if(n.value)throw x(n.value);i.value&&typeof i.value=="object"&&Object.assign(await r,M(E(i.value)))}const $=function(...f){const[e,c]=f,{setup:a}=e;return!a&&!e.asyncData&&!e.head?{[g]:!0,...e}:{[g]:!0,_fetchKeyBase:c,...e,setup(t,p){const y=h(),i=a?Promise.resolve(y.runWithContext(()=>a(t,p))).then(l=>l||{}):{},n=[];if(e.asyncData&&n.push(I(i,e.asyncData)),e.head){const l=h();b(typeof e.head=="function"?()=>e.head(l):e.head)}return Promise.resolve(i).then(()=>Promise.all(n)).then(()=>i).finally(()=>{n.length=0})}}};export{$ as d};
